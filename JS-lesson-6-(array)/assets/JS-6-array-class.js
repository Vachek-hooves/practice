/* ARRAY */
// Масиви це впорядкована коллекція данних.
// Масиви НЕ Є окремим типоп данних в js і відносяться до об'єктів.
// Оголошуються:
// 1-й варіант через конструктор Array.
let Arr = new Array();
// 2-й спосіб через літерал.
// let arr = [] // через квадратні дужки.

let fruit = ["apple"] // Елементи списку не мають назви ключів, ці ключі мають номери і починаються з нуля "0"!!!
// замість ключа,що був в обєкті, в масиві цифри. За номером можна отримати значення елемента в масиві.

console.log(fruit[0]) //в консолі виведеться "apple"
console.log(fruit[2]) // якщо в масиві немає елемента, то в консолі виведеться undefined.
// За номером можна додати елемент в масив.
fruit[4] = "orange"; // додається елемент "orange".
console.log(fruit) 
// fruits[ index ] = "orange" - номер індексу можна ставити який завгодно і під таким номером створиться значення.
//
// крім того в масиві зберігається загальна кількість елементів. Їх можна отримати за допомогою "length"
console.log(fruit.length) // Довжина масиву стала 5. Тому що є 1-й "apple" потім 3 порожніх і 4-й "orange".

// В масиві може зберігатися будь-який тип.
let newFruit = ["apple", 1, null , {name:"Ivan",age: 12}]; 
console.log(newFruit);
// звернення до name:"Ivan".
console.log(newFruit[3].name) // вивести значення ключя name.
console.log(newFruit[3].age)  // вивести значення ключя age.

//
let fruitsF = ["apple","orange","banana","pear"];
// Часто буває так що невідомо  скільки елементів в масиві, масив буде динамічно змінюватися і щоразу буде інший.
console.log(fruitsF[0]) // так отримується 1-й елемент.
// Якщо потрібно оримати останній елемент а кількість їх невідома тоді..
console.log(fruitsF[fruitsF.length - 1]) // Береться довжина масиву і віднімається 1, тому що індексація масиву рахується з "0"
// в такому випадку консоль повертає останній варінт.
// Ще один спосіб за допомогою "at". спосіб новий і не підримуєтсья всіма браузерами.
console.log(fruitsF.at(-1)) // отримується останній елемент.    аналагічно "console.log(fruitsF[fruitsF.length - 1])"
console.log(fruitsF.at(-2)) // отримується 2-й з кіньця.
console.log(fruitsF.at(0)) // поверне 1-й елемент.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* МЕТОДИ */
// робота з додаванням і відніманням з початку і кінця масиву.
// Є 4-ри методи.

/* 1-й метод "shift"  вилучення*/
// синтаксис 
// console.log(fruits.shift()) // вилучення і повернення першого елементу масива (0), дужки лишаються пустими.

/* 2-й метод "unshift" додавання елемента на початок*/
// синтаксис 
// console.log(fruits.unshift("Lemon")) // в дужках вказується значення елементу,що додається. Unshift- повертає довжину масиву.

/* 3-й метод "pop" видалення останнього елемента */
// синтаксис 
// console.log(fruits.pop()) // вилучення і повернення останього елемента масиву.

/* 4-й метод "push" додавання елемента в кінець */
// синтаксис
// console.log(fruits.push("melon")) // додавання елемента в кінець.

// push & unshift можна вказувати будь-яку кількість елементів
// console.log(fruits.unshift("Lemon", "Lemon2"))
// console.log(fruits.push("apple", "apple 2")) // в масиві може міститися декілька однакових елементів.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* ПОРІВНЯННЯ  */
// Так само як і в об'єктах. Тобто масиви не можна порівнювати через дорівнює. 
// тому що змінна яка зберігає масив або об'єкт містять його не фізично а зберігають посилання на комірку пам'яті де зберігається масив.
// перше що перевіряють на рівність масивів це length, а наступна ітерація це значення.

// let arr = fruits; // тільки в такому випадку вони будуть рівні. Тому що зберігають посилання на одну комірку пам'яті.
// console.log( arr == fruits);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* for */
// якщо потрібно отримати "key" та "value"
/* спосіб пройтись по масиву, це цикл for */
let fruitsFor = ["apple","orange","banana","pear"];

for (let i=0; i < fruitsFor.length; i++){
    console.log(fruitsFor[i]) // отримується індекс з масиву (зі змінної fruits).  
};

for (let i=0; i < fruitsFor.length; i++){
    console.log(i, fruitsFor[i]) // в операторі for "i"  виводиться як числове значення і означає позицію в масиві.
};

for (let i=0; i < fruitsFor.length; i++){
    console.log(fruitsFor[i].toUpperCase()); // через цикл зробити слова з великими літерами.
};

// ще варіант
let forFruits = ["apple","orange","banana","pear",3,{name:"Slava", age: "nun"}];

for (let i = 0; i < forFruits.length; i++){
    console.log(forFruits[i]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* for of */
// Якщо потрібно отримати тільки "value"
let fruitForOf = ["apple","orange","banana","pear"];

for (let fruitNew of fruitForOf ){ // комбінація "let fruitNew"- створення змінної, яка буде в собі містити кожне значення масиву "fruits"
    console.log(fruitNew)  // доступу до ітератора немає,виводиться просто значення. 
    // console.log(typeof fruit === number) // перевірка чи є fruit  числом
};

for (let fruitNew of fruitForOf ){
    console.log(typeof fruitNew === "number");
};

for (let fruitNew of fruitForOf ){
    console.log(typeof fruitNew !==Number)// перевірка чи fruit не є числове.
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* for in */
let fruitForIn = ["apple","orange","banana","pear"];
for (let key in fruitForIn){
    // console.log(fruitForIn[key]) // як варіант але не застосовується на практиці для масивів, він дуже повільний.
    console.log(key,fruitForIn[key]) // виводиться як стрічка.
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* створення функції в масиві */
// перевіремо чи є можливість створити метод в масиві як і в об'єкті.
// через function declaration
let fruitFunction = ["apple","orange","banana","pear"];
function fruitsFunction(){
    console.log(123);
}
fruitFunction[4] = fruitsFunction; // присвоення функції масиву.
// fruitFunction[4](); //виклик функції. Так ніколи не використовується, але можливість є.
console.log(fruitFunction)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Отриманя аргументів */
function fruitsFunction(a,b){ // В цій функції записано 2 аргументи a b.
    console.log(arguments, arguments[3]); // виводить масив та виводиться аргумент 4 -й по черзі, (в консолі буде вкінці)
    console.log(arguments[2]); // Виводеться 2-й аргумент функції (рахується з 0)
    console.log(arguments.length); // вивести довжину аргументів( в данному випадку їх 5).
}
fruitsFunction(1,5,3,3,5) // Передано в фунцію 5 аргументів, їх отримати не можна. Дл цього існує змінна "arguments".
// передаються аргументи в такому порядку як і записані у виклику функції.
// Використання в function expression.
let fruitsFunctionVar = function(){
    console.log(arguments, arguments[3]); // виводить масив та виводиться аргумент 4 -й по черзі.
    console.log(arguments[2]); // Виводеться 2-й аргумент функції (рахується з 0)
    console.log(arguments.length); // вивести довжину аргументів( в данному випадку їх 5).
};

// fruitsFunctionVar(1,5,3,6,4); // Все пряцює так само як і в function declaration.

// Стрілочні функції.

// let fruitsArrow =() => console.log(arguments) // в будь-якому варінті стрілочні функції будуть "is not defined". Тобто, стрілочні функції "arguments" не мають.
// fruitsArrow(1,4,3,2);

/* метод видалення в масиві */

// delete fruits[0]; // видаляється значення але елементи не сунуться. Краще використовувати методи push, pop, shift, unshift.
// console.log(fruits);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* SPLICE  - універсальний метод роботи з масивами !!!*/
// splice - вміє додавати, вилучати і замінювати елементи.
// цей метод працює з будь-яким відрізком об'єкту.
// синтаксис: array.splice().
let fruitsSlice = ["apple","orange","banana","pear","kiwi"];
// console.log(fruitsSlice.splice(1,1)) // видаляється (вилучається) елемент з індуксом 1 і він же повертається.
// console.log(fruitsSlice.splice(2,2)) // видаляється 2 елементи починаючи з другого. (2, 2)- (з другого елементу, наступні 2 елементи)
console.log(fruitsSlice.splice(2)) // видалиться з вказаного індексу і до кінця.
console.log(fruitsSlice)

/* додавання (вставлення) в об'єкт  */
// console.log(fruits.splice(1,2, "test 1", "test 2")) // (1-на який індекс додається, 2 - скільки елементів видаляється, test 1- додається, test 2- додається)
// console.log(fruits)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* slice - метод копіювання значення масиву*/
// функціонал простіше ніж splice.
// slice - бере від початкового індексу до кінцевого індексу, не включаючи кінцевий індекс і повертає новий масив копіюючи до нього всі елементи із вказаного проміжку.

// console.log(fruits.slice(1,3));// скопіюється 1-й та 2-й індекс, тому що цифра 1-початок і 3-й кінець( але slice не вкючає останній).
// let copiedFruits = fruits.slice(1,3); // створюється новий масив "copiedFruits" з індексами 1 і 2. А масив fruits залишається незміний.
// console.log(copiedFruits);
// Якщо вказується від'ємний індекс
// console.log(fruits.slice(-2)) // це означає, що починається відлік з 2 індексу з кінця і до кінця.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* concat  */
//- метод що створює новий масив, який копіює данні з інших масивів і додаткові значення.

let array = [3,4]
let fruitConcat = ["apple","orange","banana","pear","kiwi"];

let arr1 = fruitConcat.concat(array, [5,6]); // створюється новий масив "arr" який перекопіює "fruits" і нові масиви.
// можливий і такий варіант
let arr = fruitConcat.concat(array, fruitConcat.slice(2), 5,6); // буде так само як і з масивом "arr1"
console.log(fruitConcat); // масив fruits не змінився.
console.log(arr); // В arr додалось значення з "fruits" та аргументи з concat.
console.log(arr1);

/* матод перебору в масивах */
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// forEach перебрати в середині і щось змінити.
// синтаксис - array.forEach(function(item,index,array){}) 
fruitConcat.forEach(function(item, index, array) {
    // console.log(item, index , array) // item- вивести всі айтеми почерзі, index- вивести почерзі index які є в масиві. array - повернеться вихідний масив, тут це "fruits".
    console.log(`unit ${item} with position ${index} in array ${array}`) // array - вказується якщо ньому хочемо вивести якусь інформацію.
    // назви (item, index, array) - можуть бути будь-якими.
});

/* модифікація перебору forEach, може бути стрілкова функція */
// якщо не потрібно ні index, ні array.
// синтаксис: array.forEach((item, index, array) => {console.log(item, index, array)});
fruitConcat.forEach((fruit, index, array) => {console.log(fruit,index,array)});


// розібрати зазначені нижче методи, які шукають index.
// lastIndexOf.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* indexOf */
// Синтаксис - arr.indexOf(item,from) - шукає item, починаючи с індексу from, і повертає індекс, на який був знайдений елемент,якщо не знайшов тоді  "-1".

let arrIndexOf =["Vasya","Toma","Olya",];

console.log(arrIndexOf.indexOf("Olya")+" - повертає індекс в якому знах-ся значення"); // 1 
console.log(arrIndexOf.indexOf("Dyma")); // такого знач-ня немає, тому -1
console.log(arrIndexOf.indexOf("Toma",2)); // індекс 2- це з якого індексу поч-ся пошук (не включаючи стартовий індекс).

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* includes */
// Синтаксис - arr.includes(item,from) - так само як і з indexOf, але повертає false або true.

console.log(arrIndexOf.includes("Olya")); 
console.log(arrIndexOf.includes("Dyma")); 
console.log(arrIndexOf.includes("Toma",2)); 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*  find  */
//  Синтаксис - arr.find(function(item,index,array ))
let arr2 = [
    {name: "Vasia", age: 34},
    {name: "Toma", age: 23},
    {name: "Olya", age : "no comments"},
]

let resultOne = arr2.find(function(item,index,array){ // якщо true, тоді повернтається поточний елемент і пошук зак-ся. Якщо false, тоді повертається undefined.
    return item.age === 23;                                   // return -(повертаємо якусь умову). Повертається об'єкт якщо "age" буде "18"
});
console.log(resultOne);
// item - елемент масиву, index - його ключ (позиція), array - сам масив.
// варіант зстрілковою функцією.
let result2 = arr2.find(item => item.age===23);
console.log(result2)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* findIndex */
// робить все те саме,що і find,  але повертає "1" коли true, "-1" коли false.
let result3 = arr2.findIndex(item => item.age === 23);
console.log(result3)

let fruta = ["apple","orange","banana","pear"];

console.log(fruta.find(function(item,index,array){ // в результаті пишеться умова і якщо умова виконується, тоді повертається поточний елемент.
    // якщо умова не виконалась для жодного елемента, тоді повертається undefined.
    // return item === 1;
    return item === "apple"
}));

// зазвичай через анонімну функцію не пишуть, використовується стрілкова функція.
// console.log(fruits.find(item => item === "apple")); // назва масиву.шукати (item => і цей item буде рівним === "назва").

// якщо item буде в масиві, тоді його треба шукати циклами (циклами на вкладений цикл, можливо), якщо буде масив то звертатись forEach, якщо об'єкт то звертатись по ключу.
// Приклад якщо item видалити (тоді треба знати його index) з використанняям findIndex.
fruta.splice(fruta.findIndex(item => item === "apple"),1); // дія в fruta. щось видалити splice (шукається в-fruts.findIndex-шукає індекс(item => і цей item буде рівним === "назва"), 1-кількість елементів видаляється)
console.log(fruta);


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* filter */
// filter - працює за схожим принципом як і splice.
/* синтаксис -  
arr.find(function(item,index,array){
    true - елемент додається до результату, і перевірка продовжується
    -  повертає порожній масив, також якщо нічого не знайдено.
})
*/

let filter = [
    {name: "Vasia", age: 2},
    {name: "Toma", age: 01},
    {name: "Olya", age : "no comments"},
]
let resultFilter = filter.filter(function(item,index,array){
    return item.age >= 18;
})
console.log(resultFilter)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*    sort   */
// сортується масив на місці,змінюючи в ньому порядок елементів.
// приклад: сортування слів.
let arrSort = ["Olga","Jack","Name",];
console.log(arrSort.sort());

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*    reverse  */
// reverse - змінює порядок елементів в масиві. 
let arrReverse = ["Olga","Jack","Name",];
console.log(arrReverse.reverse());

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// split
// модифікує стрічку в масив за заданим розмежувачем.( наприклад кома ",")
let arrSplit = "opel, mazda, kia";

let newSplit = arrSplit.split(',')
console.log(newSplit);

// Можливо обмежити кількість об'єктів котрі потраплять в масив.
let letSplit = arrSplit.split(",",2); // виводить тільки 2 елементи і розділяє їх комою ","
console.log(letSplit);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// join
// модифікує стрічку в масив з заданим розмежувачем (наприклад "^")
let arrJoin = ["Opel","Mazda","Kia"];
console.log(arrJoin.join("^"));

console.log(String(arrJoin)); // - так теж модифікує масив в стрічу, але завжди тільки через кому.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// filter- в результаті повертає новий масив, відфільтрованний без цього значення.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Map */
// Використовується коли треба модифікувати item використовувати map а не forEach.
// викликає функцію для кожного елемента масиву і пвертає масив з результатом цієї функції.
/* синтаксис - arr.map(function(item,index,array){
    // повертає нове значення замість елемента
})
*/
let map = ["apple","orange","banana","pear"];

let arrMap = map.map(function(item,index,array){
    return item[1];
})
console.log(arrMap)
// у вигляді стрілкової
let arrMapNew = map.map(item => item[1]);
console.log(arrMapNew);

// Приклад: додати "juice " до кожного item.
// Тоді треба переприсвоїти масив frute з тими самими значеннями. 
fruta = fruta.map(item => item + " juice"); // додавання "juice" до кожного item.
console.log(fruta);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* isArray */
// Ця функція для того щоб перевірити чи змінна є масивом.



// синтаксис - Array.isArray({}) - Array так і пишеться.

console.log(typeof {})// Поверне значення об'єкт.
console.log(typeof [])// Теж поверне значення об'єкт.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Тому використовується метод isArray, щоб дізнятися чи змінна є масивом.
console.log(Array.isArray({})) // питається чи змінна масивом. -false
console.log(Array.isArray([])) // питається чи є змінна масивом. - true.
console.log(Array.isArray(fruta));

/* Як зробити першу стрічки з великою  */
let string = "test"; 
console.log(string.charAt().toUpperCase()+string.slice(1)); 