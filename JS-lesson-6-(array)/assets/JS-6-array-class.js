/* ARRAY */
// Масиви це впорядкована коллекція данних.
// Масиви не є окремим типоп данних і відносяться до об'єктів.
// Оголошуються:
// 1-й варіант через конструктор Array.
let Arr = new Array();
// 2-й спосіб через літерал.
// let arr = [] // через квадратні дужки.

let fruit = ["apple"] // Елементи списку не мають назви ключів, ці ключі мають номери і починаються з нуля "0"!!!
// замість ключа,що був в обєкті, в масиві цифри. За номером можна отримати значення елемента вмасиві.

console.log(fruit[0]) //в консолі виведеться "apple"
console.log(fruit[2]) // якщо в масиві немає елемента, то в консолі виведеться undefined.
// За номером можна додати елемент в масив.
fruit[4] = "orange"; // додається елемент "orange".
console.log(fruit) 
// fruits[ index ] = "orange" - номер індексу можна ставити який завгодно і під таким номером створиться значення.
//
// крім того в масиві зберігається загальна кількість елементів. Їх можна отримати за допомогою "length"
console.log(fruit.length) // Довжина масиву стала 5. Тому що є 1-й "apple" потім 3 порожніх і 4-й "orange".

// В масиві може зберігатися будь-який тип.
let newFruit = ["apple", 1, null , {name:"Ivan",age: 12}]; 
console.log(newFruit);
// звернення до name:"Ivan".
console.log(newFruit[3].name) // вивести значення ключя name.
console.log(newFruit[3].age)  // вивести значення ключя age.

//
// let fruits = ["apple","orange","banana","pear"];
// Часто буває так що невідомо  скільки елементів в масиві, масив буде динамічно змінюватися і щоразу бе інший.
// console.log(fruits[0]) // так отримується 1-й елемент.
// Якщо потрібно оримати останній елемент а кількість їх невідома тоді..
// console.log(fruits[fruits.length - 1]) // Береться довжина масиву і віднімається 1, тому що індексація масиву рахується з "0"
// в такому випадку консоль повертає останній варінт.
// Ще один спосіб за допомогою "at". спосіб новий і не підримуєтсья всіма браузерами.
// console.log(fruits.at(-1)) // отримується останній елемент.    аналагічно "console.log(fruits[fruits.length - 1])"
// console.log(fruits.at(-2)) // отримується 2-й з кіньця.
// console.log(fruits.at(0)) // поверне 1-й елемент.

/* МЕТОДИ */
// робота з додаванням і відніманням з початку і кінця масиву.
// Є 4-ри методи.

/* 1-й метод "shift"  вилучення*/
// синтаксис 
// console.log(fruits.shift()) // вилучення і повернення першого елементу масива (0), дужки лишаються пустими.

/* 2-й метод "unshift" додавання елемента на початок*/
// синтаксис 
// console.log(fruits.unshift("Lemon")) // в дужках вказується значення елементу,що додається. Unshift- повертає довжину масиву.

/* 3-й метод "pop" видалення останнього елемента */
// синтаксис 
// console.log(fruits.pop()) // вилучення і повернення останього елемента масиву.

/* 4-й метод "push" додавання елемента в кінець */
// синтаксис
// console.log(fruits.push("melon")) // додавання елемента в кінець.

// push & unshift можна вказувати будь-яку кількість елементів
// console.log(fruits.unshift("Lemon", "Lemon2"))
// console.log(fruits.push("apple", "apple 2")) // в масиві може міститися декілька однакових елементів.

/* ПОРІВНЯННЯ  */
// Так само як і в об'єктах. Тобто масиви не можна порівнювати через дорівнює. 
// тому що змінна яка зберігає масив або об'єкт містять його не фізично а зберігають посилання на комірку пам'яті де зберігається масив.
// перше що перевіряють на рівність масивів це length, а наступна ітерація це значення.

// let arr = fruits; // тільки в такому випадку вони будуть рівні. Тому що зберігають посилання на одну комірку пам'яті.
// console.log( arr == fruits);

/* спосіб пройтись по масиву, це цикл for */
let fruits = ["apple","orange","banana","pear"];

for (let i=0; i < fruits.length; i++){
    console.log(fruits[i]) // отримується індекс з масиву (зі змінної fruits).
    console.log(i, fruits[i]) // в операторі for i  виводиться як числове значення.
    console.log(fruits[i].toUpperCase()); // через цикл зробити слова з великими літерами.
}

/* for of */
for (let fruit of fruits ){
    console.log(fruit)  // доступу до ітератора немає,виводиться просто значення. 
    console.log(typeof fruit === "number");
    console.log(typeof fruit !==Number)// перевірка чи fruit не є числов.
    // console.log(typeof fruit === number) // перевірка fruit є числом
}

/* for in */
for (let key in fruits){
    console.log(fruits[key]) // як варіант але не застосовується на практиці для масивів, він дуже повільний.
    console.log(key, fruits[key]) // виводиться як стрічка.
}


